diff --git a/configure b/configure
index 6b9758f..60c7f0a 100755
--- a/configure
+++ b/configure
@@ -1380,6 +1380,7 @@ enable_wineps_drv
 enable_winepulse_drv
 enable_wineqtdecoder
 enable_winex11_drv
+enable_wineboxed_drv
 enable_wing32
 enable_winhttp
 enable_wininet
@@ -8021,7 +8022,7 @@ done
 
     APPKIT_LIBS="-framework AppKit"
 
-    LDEXECFLAGS="-image_base 0x7bf00000 -Wl,-pagezero_size,0x1000,-segaddr,WINE_DOS,0x00001000,-segaddr,WINE_SHAREDHEAP,0x7f000000,-sectcreate,__TEXT,__info_plist,wine_info.plist"
+    LDEXECFLAGS="-Wl,-pagezero_size,0x1000,-segaddr,WINE_DOS,0x00001000,-segaddr,WINE_SHAREDHEAP,0x7f000000,-sectcreate,__TEXT,__info_plist,wine_info.plist"
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-no_pie" >&5
 $as_echo_n "checking whether the compiler supports -Wl,-no_pie... " >&6; }
 if ${ac_cv_cflags__Wl__no_pie+:} false; then :
@@ -8607,7 +8608,7 @@ if ${ac_cv_cflags__Wl__Ttext_segment_0x7bc00000+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_wine_try_cflags_saved=$CFLAGS
-CFLAGS="$CFLAGS -Wl,-Ttext-segment=0x7bc00000"
+CFLAGS="$CFLAGS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
@@ -8626,7 +8627,7 @@ $as_echo "$ac_cv_cflags__Wl__Ttext_segment_0x7bc00000" >&6; }
 if test "x$ac_cv_cflags__Wl__Ttext_segment_0x7bc00000" = xyes; then :
   case $host_os in
                            freebsd* | kfreebsd*-gnu) LDEXECFLAGS="$LDEXECFLAGS -Wl,-Ttext-segment=0x60000000" ;;
-                           *) LDEXECFLAGS="$LDEXECFLAGS -Wl,-Ttext-segment=0x7c000000" ;;
+                           *) LDEXECFLAGS="$LDEXECFLAGS" ;;
                            esac
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--section-start,.interp=0x7c000400" >&5
@@ -8726,7 +8727,7 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__z_max_page_size_0x1000" >&5
 $as_echo "$ac_cv_cflags__Wl__z_max_page_size_0x1000" >&6; }
 if test "x$ac_cv_cflags__Wl__z_max_page_size_0x1000" = xyes; then :
-  LDEXECFLAGS="$LDEXECFLAGS -Wl,-z,max-page-size=0x1000"
+  LDEXECFLAGS="$LDEXECFLAGS -Wl,-z,max-page-size=0x1000 -pie"
 fi
           ;;
       esac
@@ -18112,6 +18113,7 @@ wine_fn_config_dll wineps16.drv16 enable_win16
 wine_fn_config_dll winepulse.drv enable_winepulse_drv
 wine_fn_config_dll wineqtdecoder enable_wineqtdecoder
 wine_fn_config_dll winex11.drv enable_winex11_drv
+wine_fn_config_dll wineboxed.drv enable_wineboxed_drv
 wine_fn_config_dll wing.dll16 enable_win16
 wine_fn_config_dll wing32 enable_wing32
 wine_fn_config_dll winhttp enable_winhttp clean,implib
diff --git a/configure.ac b/configure.ac
index f25c965..cb606d7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3359,6 +3359,7 @@ WINE_CONFIG_DLL(wineps16.drv16,enable_win16)
 WINE_CONFIG_DLL(winepulse.drv)
 WINE_CONFIG_DLL(wineqtdecoder)
 WINE_CONFIG_DLL(winex11.drv)
+WINE_CONFIG_DLL(wineboxed.drv)
 WINE_CONFIG_DLL(wing.dll16,enable_win16)
 WINE_CONFIG_DLL(wing32)
 WINE_CONFIG_DLL(winhttp,,[clean,implib])
diff --git a/dlls/kernel32/Makefile.in b/dlls/kernel32/Makefile.in
index 1399859..6668aec 100644
--- a/dlls/kernel32/Makefile.in
+++ b/dlls/kernel32/Makefile.in
@@ -3,7 +3,7 @@ MODULE    = kernel32.dll
 IMPORTLIB = kernel32
 IMPORTS   = winecrt0 ntdll
 EXTRALIBS = $(COREFOUNDATION_LIBS) $(POLL_LIBS)
-EXTRADLLFLAGS = -nodefaultlibs -Wb,-F,KERNEL32.dll -Wl,--image-base,0x7b400000
+EXTRADLLFLAGS = -nodefaultlibs -Wb,-F,KERNEL32.dll
 
 C_SRCS = \
 	actctx.c \
diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 4771108..d5c34d4 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -1220,7 +1220,7 @@ void CDECL __wine_kernel_init(void)
         }
         update_library_argv0( main_exe_name );
         if (!build_command_line( __wine_main_wargv )) goto error;
-        start_wineboot( boot_events );
+        //start_wineboot( boot_events );
     }
 
     /* if there's no extension, append a dot to prevent LoadLibrary from appending .dll */
@@ -1534,9 +1534,11 @@ static int fork_and_exec( const char *filename, const WCHAR *cmdline, const WCHA
     argv = build_argv( cmdline, 0 );
     envp = build_envp( env );
 
-    if (!(pid = fork()))  /* child */
+    if (!(pid = vfork()))  /* child */
     {
+#ifndef BOXEDWINE
         if (!(pid = fork()))  /* grandchild */
+#endif
         {
             close( fd[0] );
 
@@ -1578,7 +1580,7 @@ static int fork_and_exec( const char *filename, const WCHAR *cmdline, const WCHA
 
             if (argv && envp) execve( filename, argv, envp );
         }
-
+#ifndef BOXEDWINE
         if (pid <= 0)  /* grandchild if exec failed or child if fork failed */
         {
             err = errno;
@@ -1586,7 +1588,8 @@ static int fork_and_exec( const char *filename, const WCHAR *cmdline, const WCHA
             _exit(1);
         }
 
-        _exit(0); /* child if fork succeeded */
+       _exit(0); /* child if fork succeeded */
+#endif
     }
     HeapFree( GetProcessHeap(), 0, argv );
     HeapFree( GetProcessHeap(), 0, envp );
@@ -1594,6 +1597,8 @@ static int fork_and_exec( const char *filename, const WCHAR *cmdline, const WCHA
     if (stdout_fd != -1) close( stdout_fd );
     if (stderr_fd != -1) close( stderr_fd );
     close( fd[1] );
+
+#ifndef BOXEDWINE
     if (pid != -1)
     {
         /* reap child */
@@ -1608,6 +1613,7 @@ static int fork_and_exec( const char *filename, const WCHAR *cmdline, const WCHA
         }
     }
     if (pid == -1) FILE_SetDosError();
+#endif
     close( fd[0] );
     return pid;
 }
@@ -1866,9 +1872,11 @@ static pid_t exec_loader( LPCWSTR cmd_line, unsigned int flags, int socketfd,
     if (!is_win64 ^ !(binary_info->flags & BINARY_FLAG_64BIT))
         loader = get_alternate_loader( &wineloader );
 
-    if (exec_only || !(pid = fork()))  /* child */
+    if (exec_only || !(pid = vfork()))  /* child */
     {
+#ifndef BOXEDWINE
         if (exec_only || !(pid = fork()))  /* grandchild */
+#endif
         {
             char preloader_reserve[64], socket_env[64];
 
@@ -1920,10 +1928,12 @@ static pid_t exec_loader( LPCWSTR cmd_line, unsigned int flags, int socketfd,
             }
             _exit(1);
         }
-
+#ifndef BOXEDWINE
         _exit(pid == -1);
+#endif
     }
 
+#ifndef BOXEDWINE
     if (pid != -1)
     {
         /* reap child */
@@ -1932,7 +1942,7 @@ static pid_t exec_loader( LPCWSTR cmd_line, unsigned int flags, int socketfd,
             wret = waitpid(pid, NULL, 0);
         } while (wret < 0 && errno == EINTR);
     }
-
+#endif
     HeapFree( GetProcessHeap(), 0, wineloader );
     HeapFree( GetProcessHeap(), 0, argv );
     return pid;
diff --git a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
index ed4bb94..68ebe6f 100644
--- a/dlls/ntdll/Makefile.in
+++ b/dlls/ntdll/Makefile.in
@@ -3,7 +3,7 @@ MODULE    = ntdll.dll
 IMPORTLIB = ntdll
 IMPORTS   = winecrt0
 EXTRALIBS = $(IOKIT_LIBS) $(RT_LIBS) $(PTHREAD_LIBS)
-EXTRADLLFLAGS = -nodefaultlibs -Wl,--image-base,0x7bc00000
+EXTRADLLFLAGS = -nodefaultlibs
 
 C_SRCS = \
 	actctx.c \
diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index a0049fe..e5f83fc 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -1718,6 +1718,9 @@ static NTSTATUS perform_relocations( void *module, SIZE_T len )
     {
         WARN( "Need to relocate module from %p to %p, but there are no relocation records\n",
               base, module );
+#ifdef BOXEDWINE
+	return STATUS_SUCCESS;
+#endif
         return STATUS_CONFLICTING_ADDRESSES;
     }
 
@@ -1794,10 +1797,9 @@ static NTSTATUS load_native_dll( LPCWSTR load_path, LPCWSTR name, HANDLE file,
                                  &module, 0, 0, &size, &len, ViewShare, 0, PAGE_EXECUTE_READ );
 
     /* perform base relocation, if necessary */
-
-    if (status == STATUS_IMAGE_NOT_AT_BASE)
+    if (status == STATUS_IMAGE_NOT_AT_BASE) {
         status = perform_relocations( module, len );
-
+    }
     if (status != STATUS_SUCCESS)
     {
         if (module) NtUnmapViewOfSection( NtCurrentProcess(), module );
diff --git a/dlls/ntdll/server.c b/dlls/ntdll/server.c
index 356d631..2e251d9 100644
--- a/dlls/ntdll/server.c
+++ b/dlls/ntdll/server.c
@@ -1090,7 +1090,7 @@ static void start_server(void)
     if (!started)
     {
         int status;
-        int pid = fork();
+        int pid = vfork();
         if (pid == -1) fatal_perror( "fork" );
         if (!pid)
         {
@@ -1100,10 +1100,10 @@ static void start_server(void)
             wine_exec_wine_binary( argv[0], argv, getenv("WINESERVER") );
             fatal_error( "could not exec wineserver\n" );
         }
-        waitpid( pid, &status, 0 );
-        status = WIFEXITED(status) ? WEXITSTATUS(status) : 1;
-        if (status == 2) return;  /* server lock held by someone else, will retry later */
-        if (status) exit(status);  /* server failed */
+        //waitpid( pid, &status, 0 );
+        //status = WIFEXITED(status) ? WEXITSTATUS(status) : 1;
+        //if (status == 2) return;  /* server lock held by someone else, will retry later */
+        //if (status) exit(status);  /* server failed */
         started = TRUE;
     }
 }
diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index f6a5fbe..fb6fce4 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -226,11 +226,17 @@ HANDLE thread_init(void)
     virtual_init();
 
     /* reserve space for shared user data */
-
     addr = (void *)0x7ffe0000;
     size = 0x10000;
     status = NtAllocateVirtualMemory( NtCurrentProcess(), &addr, 0, &size,
                                       MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE );
+#ifdef BOXEDWINE
+    if (status) {
+        addr = NULL;
+        status = NtAllocateVirtualMemory( NtCurrentProcess(), &addr, 0, &size,
+                                      MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE );
+    }
+#endif
     if (status)
     {
         MESSAGE( "wine: failed to map the shared user data: %08x\n", status );
diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
index 5c43d26..08307e4 100644
--- a/dlls/ntdll/virtual.c
+++ b/dlls/ntdll/virtual.c
@@ -844,8 +844,9 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
             }
             TRACE( "got mem with anon mmap %p-%p\n", ptr, (char *)ptr + size );
             /* if we got something beyond the user limit, unmap it and retry */
-            if (is_beyond_limit( ptr, view_size, user_space_limit )) add_reserved_area( ptr, view_size );
-            else break;
+            // if (is_beyond_limit( ptr, view_size, user_space_limit )) add_reserved_area( ptr, view_size );
+            // else break;
+            break;
         }
         ptr = unmap_extra_space( ptr, view_size, size, mask );
     }
diff --git a/dlls/wineboxed.drv/Makefile.in b/dlls/wineboxed.drv/Makefile.in
new file mode 100755
index 0000000..8631e75
--- /dev/null
+++ b/dlls/wineboxed.drv/Makefile.in
@@ -0,0 +1,8 @@
+MODULE    = wineboxed.drv
+IMPORTS   = uuid user32 gdi32 advapi32
+DELAYIMPORTS = ole32 shell32 imm32
+EXTRALIBS = $(PTHREAD_LIBS)
+
+C_SRCS = wineboxed.c surface.c
+
+RC_SRCS = wineboxed.rc
diff --git a/dlls/wineboxed.drv/boxeddrv_res.h b/dlls/wineboxed.drv/boxeddrv_res.h
new file mode 100755
index 0000000..6a56fc7
--- /dev/null
+++ b/dlls/wineboxed.drv/boxeddrv_res.h
@@ -0,0 +1,41 @@
+/*
+ * Resource ID constants for BoxedWine driver
+ *
+ * Copyright (c) 2013 Ken Thomases for CodeWeavers Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_MACDRV_RES_H
+#define __WINE_MACDRV_RES_H
+
+
+/* Strings */
+#define STRING_MENU_WINE                        0x100
+#define STRING_MENU_ITEM_HIDE_APPNAME           0x101
+#define STRING_MENU_ITEM_HIDE                   0x102
+#define STRING_MENU_ITEM_HIDE_OTHERS            0x103
+#define STRING_MENU_ITEM_SHOW_ALL               0x104
+#define STRING_MENU_ITEM_QUIT_APPNAME           0x105
+#define STRING_MENU_ITEM_QUIT                   0x106
+
+#define STRING_MENU_WINDOW                      0x110
+#define STRING_MENU_ITEM_MINIMIZE               0x111
+#define STRING_MENU_ITEM_ZOOM                   0x112
+#define STRING_MENU_ITEM_ENTER_FULL_SCREEN      0x113
+#define STRING_MENU_ITEM_BRING_ALL_TO_FRONT     0x114
+
+
+#endif
diff --git a/dlls/wineboxed.drv/surface.c b/dlls/wineboxed.drv/surface.c
new file mode 100755
index 0000000..e11df45
--- /dev/null
+++ b/dlls/wineboxed.drv/surface.c
@@ -0,0 +1,392 @@
+// Ported from the mac driver by James Bryant
+
+/*
+ * Mac driver window surface implementation
+ *
+ * Copyright 1993, 1994, 2011 Alexandre Julliard
+ * Copyright 2006 Damjan Jovanovic
+ * Copyright 2012, 2013 Ken Thomases for CodeWeavers, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <pthread.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "wine/debug.h"
+#include "wine/gdi_driver.h"
+#include "winreg.h"
+
+#include "winuser.h"
+#include "winternl.h"
+#include "winnt.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(boxeddrv);
+
+
+/* only for use on sanitized BITMAPINFO structures */
+static inline int get_dib_info_size(const BITMAPINFO *info, UINT coloruse)
+{
+    if (info->bmiHeader.biCompression == BI_BITFIELDS)
+        return sizeof(BITMAPINFOHEADER) + 3 * sizeof(DWORD);
+    if (coloruse == DIB_PAL_COLORS)
+        return sizeof(BITMAPINFOHEADER) + info->bmiHeader.biClrUsed * sizeof(WORD);
+    return FIELD_OFFSET(BITMAPINFO, bmiColors[info->bmiHeader.biClrUsed]);
+}
+
+static inline int get_dib_stride(int width, int bpp)
+{
+    return ((width * bpp + 31) >> 3) & ~3;
+}
+
+static inline int get_dib_image_size(const BITMAPINFO *info)
+{
+    return get_dib_stride(info->bmiHeader.biWidth, info->bmiHeader.biBitCount)
+        * abs(info->bmiHeader.biHeight);
+}
+
+static inline void reset_bounds(RECT *bounds)
+{
+    bounds->left = bounds->top = INT_MAX;
+    bounds->right = bounds->bottom = INT_MIN;
+}
+
+
+struct boxeddrv_window_surface
+{
+    struct window_surface   header;
+    HWND                    window;
+    RECT                    bounds;
+    HRGN                    region;
+    HRGN                    drawn;
+    BOOL                    use_alpha;
+    RGNDATA                *blit_data;
+    BYTE                   *bits;
+    pthread_mutex_t         mutex;
+    BITMAPINFO              info;   /* variable size, must be last */
+};
+
+static struct boxeddrv_window_surface *get_boxed_surface(struct window_surface *surface)
+{
+    return (struct boxeddrv_window_surface *)surface;
+}
+
+RGNDATA *get_region_data(HRGN hrgn, HDC hdc_lptodp)
+{
+	RGNDATA *data;
+	DWORD size;
+	int i;
+	RECT *rect;
+
+	if (!hrgn || !(size = GetRegionData(hrgn, 0, NULL))) return NULL;
+	if (!(data = HeapAlloc(GetProcessHeap(), 0, size))) return NULL;
+	if (!GetRegionData(hrgn, size, data))
+	{
+		HeapFree(GetProcessHeap(), 0, data);
+		return NULL;
+	}
+
+	rect = (RECT *)data->Buffer;
+	if (hdc_lptodp)  /* map to device coordinates */
+	{
+		LPtoDP(hdc_lptodp, (POINT *)rect, data->rdh.nCount * 2);
+		for (i = 0; i < data->rdh.nCount; i++)
+		{
+			if (rect[i].right < rect[i].left)
+			{
+				INT tmp = rect[i].right;
+				rect[i].right = rect[i].left;
+				rect[i].left = tmp;
+			}
+			if (rect[i].bottom < rect[i].top)
+			{
+				INT tmp = rect[i].bottom;
+				rect[i].bottom = rect[i].top;
+				rect[i].top = tmp;
+			}
+		}
+	}
+	return data;
+}
+
+/***********************************************************************
+ *              update_blit_data
+ */
+static void update_blit_data(struct boxeddrv_window_surface *surface)
+{
+    HeapFree(GetProcessHeap(), 0, surface->blit_data);
+    surface->blit_data = NULL;
+
+    if (surface->drawn)
+    {
+        HRGN blit = CreateRectRgn(0, 0, 0, 0);
+
+        if (CombineRgn(blit, surface->drawn, 0, RGN_COPY) > NULLREGION &&
+            (!surface->region || CombineRgn(blit, blit, surface->region, RGN_AND) > NULLREGION) &&
+            OffsetRgn(blit, surface->header.rect.left, surface->header.rect.top) > NULLREGION)
+            surface->blit_data = get_region_data(blit, 0);
+
+        DeleteObject(blit);
+    }
+}
+
+/***********************************************************************
+ *              boxeddrv_surface_lock
+ */
+static void boxeddrv_surface_lock(struct window_surface *window_surface)
+{
+    struct boxeddrv_window_surface *surface = get_boxed_surface(window_surface);
+
+    pthread_mutex_lock(&surface->mutex);
+}
+
+/***********************************************************************
+ *              boxeddrv_surface_unlock
+ */
+static void boxeddrv_surface_unlock(struct window_surface *window_surface)
+{
+    struct boxeddrv_window_surface *surface = get_boxed_surface(window_surface);
+
+    pthread_mutex_unlock(&surface->mutex);
+}
+
+/***********************************************************************
+ *              boxeddrv_surface_get_bitmap_info
+ */
+static void *boxeddrv_surface_get_bitmap_info(struct window_surface *window_surface,
+                                            BITMAPINFO *info)
+{
+    struct boxeddrv_window_surface *surface = get_boxed_surface(window_surface);
+
+    memcpy(info, &surface->info, get_dib_info_size(&surface->info, DIB_RGB_COLORS));
+    return surface->bits;
+}
+
+/***********************************************************************
+ *              boxeddrv_surface_get_bounds
+ */
+static RECT *boxeddrv_surface_get_bounds(struct window_surface *window_surface)
+{
+    struct boxeddrv_window_surface *surface = get_boxed_surface(window_surface);
+
+    TRACE("bounds = %s\n", wine_dbgstr_rect(&surface->bounds));
+    return &surface->bounds;
+}
+
+/***********************************************************************
+ *              boxeddrv_surface_set_region
+ */
+static void boxeddrv_surface_set_region(struct window_surface *window_surface, HRGN region)
+{
+    struct boxeddrv_window_surface *surface = get_boxed_surface(window_surface);
+
+    TRACE("updating surface %p with %p\n", surface, region);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (region)
+    {
+        if (!surface->region) surface->region = CreateRectRgn(0, 0, 0, 0);
+        CombineRgn(surface->region, region, 0, RGN_COPY);
+    }
+    else
+    {
+        if (surface->region) DeleteObject(surface->region);
+        surface->region = 0;
+    }
+    update_blit_data(surface);
+
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *              boxeddrv_surface_flush
+ */
+void boxeddrv_FlushSurface(HWND hwnd, void* bits, int xOrg, int yOrg, int width, int height, RECT* rect, RECT* rects, int rectCount);
+static void boxeddrv_surface_flush(struct window_surface *window_surface)
+{
+    struct boxeddrv_window_surface *surface = get_boxed_surface(window_surface);
+    HRGN region;
+
+    window_surface->funcs->lock(window_surface);
+
+    TRACE("flushing %p %s bounds %s bits %p\n", surface, wine_dbgstr_rect(&surface->header.rect),
+          wine_dbgstr_rect(&surface->bounds), surface->bits);
+
+    if (!IsRectEmpty(&surface->bounds) && (region = CreateRectRgnIndirect(&surface->bounds)))
+    {
+        if (surface->drawn)
+        {
+            TRACE("drawn += bounds");
+            CombineRgn(surface->drawn, surface->drawn, region, RGN_OR);
+            DeleteObject(region);
+        }
+        else
+        {
+            TRACE("drawn = bounds");
+            surface->drawn = region;
+        }
+    }
+    update_blit_data(surface);
+    reset_bounds(&surface->bounds);
+    window_surface->funcs->unlock(window_surface);	
+
+    if (surface->blit_data)
+    {
+        RECT r;
+
+        GetWindowRect(surface->window, &r);
+        boxeddrv_FlushSurface(surface->window, surface->bits, r.left, r.top, surface->info.bmiHeader.biWidth, surface->info.bmiHeader.biHeight, &surface->header.rect, (RECT*)surface->blit_data->Buffer, surface->blit_data->rdh.nCount);
+    }
+}
+
+/***********************************************************************
+ *              boxeddrv_surface_destroy
+ */
+static void boxeddrv_surface_destroy(struct window_surface *window_surface)
+{
+    struct boxeddrv_window_surface *surface = get_boxed_surface(window_surface);
+
+    TRACE("freeing %p bits %p\n", surface, surface->bits);
+    HeapFree(GetProcessHeap(), 0, surface->bits);
+    pthread_mutex_destroy(&surface->mutex);
+    HeapFree(GetProcessHeap(), 0, surface);
+}
+
+static const struct window_surface_funcs boxeddrv_surface_funcs =
+{
+    boxeddrv_surface_lock,
+    boxeddrv_surface_unlock,
+    boxeddrv_surface_get_bitmap_info,
+    boxeddrv_surface_get_bounds,
+    boxeddrv_surface_set_region,
+    boxeddrv_surface_flush,
+    boxeddrv_surface_destroy,
+};
+
+/***********************************************************************
+ *              create_surface
+ */
+struct window_surface *create_surface(HWND window, const RECT *rect, struct window_surface *old_surface, BOOL use_alpha)
+{
+    struct boxeddrv_window_surface *surface;
+    struct boxeddrv_window_surface *old_boxed_surface = get_boxed_surface(old_surface);
+    int width = rect->right - rect->left, height = rect->bottom - rect->top;
+    DWORD *colors;
+    pthread_mutexattr_t attr;
+    int err;
+
+    surface = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                        FIELD_OFFSET(struct boxeddrv_window_surface, info.bmiColors[3]));
+    if (!surface) return NULL;
+
+    err = pthread_mutexattr_init(&attr);
+    if (!err)
+    {
+        err = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
+        if (!err)
+            err = pthread_mutex_init(&surface->mutex, &attr);
+        pthread_mutexattr_destroy(&attr);
+    }
+    if (err)
+    {
+        HeapFree(GetProcessHeap(), 0, surface);
+        return NULL;
+    }
+
+    surface->info.bmiHeader.biSize        = sizeof(surface->info.bmiHeader);
+    surface->info.bmiHeader.biWidth       = width;
+    surface->info.bmiHeader.biHeight      = height; /* bottom-up */
+    surface->info.bmiHeader.biPlanes      = 1;
+    surface->info.bmiHeader.biBitCount    = 32;
+    surface->info.bmiHeader.biSizeImage   = get_dib_image_size(&surface->info);
+    surface->info.bmiHeader.biCompression = BI_RGB;
+    surface->info.bmiHeader.biClrUsed     = 0;
+
+    colors = (DWORD *)((char *)&surface->info + surface->info.bmiHeader.biSize);
+    colors[0] = 0x00ff0000;
+    colors[1] = 0x0000ff00;
+    colors[2] = 0x000000ff;
+
+    surface->header.funcs = &boxeddrv_surface_funcs;
+    surface->header.rect  = *rect;
+    surface->header.ref   = 1;
+    surface->window = window;
+    reset_bounds(&surface->bounds);
+    if (old_boxed_surface && old_boxed_surface->drawn)
+    {
+        surface->drawn = CreateRectRgnIndirect(rect);
+        OffsetRgn(surface->drawn, -rect->left, -rect->top);
+        if (CombineRgn(surface->drawn, surface->drawn, old_boxed_surface->drawn, RGN_AND) <= NULLREGION)
+        {
+            DeleteObject(surface->drawn);
+            surface->drawn = 0;
+        }
+    }
+    update_blit_data(surface);
+    surface->use_alpha = use_alpha;
+    surface->bits = HeapAlloc(GetProcessHeap(), 0, surface->info.bmiHeader.biSizeImage);
+    if (!surface->bits) goto failed;
+    memset(surface->bits, 0x80, surface->info.bmiHeader.biSizeImage);
+
+    TRACE("created %p for %p %s bits %p-%p\n", surface, window, wine_dbgstr_rect(rect),
+          surface->bits, surface->bits + surface->info.bmiHeader.biSizeImage);
+
+    return &surface->header;
+
+failed:
+    boxeddrv_surface_destroy(&surface->header);
+    return NULL;
+}
+
+
+/***********************************************************************
+*              surface_clip_to_visible_rect
+*
+* Intersect the accumulated drawn region with a new visible rect,
+* effectively discarding stale drawing in the surface slack area.
+*/
+void surface_clip_to_visible_rect(struct window_surface *window_surface, const RECT *visible_rect)
+{
+	struct boxeddrv_window_surface *surface = get_boxed_surface(window_surface);
+
+	window_surface->funcs->lock(window_surface);
+
+	if (surface->drawn)
+	{
+		RECT rect;
+		HRGN region;
+
+		rect = *visible_rect;
+		OffsetRect(&rect, -rect.left, -rect.top);
+
+		if ((region = CreateRectRgnIndirect(&rect)))
+		{
+			CombineRgn(surface->drawn, surface->drawn, region, RGN_AND);
+			DeleteObject(region);
+
+			update_blit_data(surface);
+		}
+	}
+
+	window_surface->funcs->unlock(window_surface);
+}
\ No newline at end of file
diff --git a/dlls/wineboxed.drv/wineboxed.c b/dlls/wineboxed.drv/wineboxed.c
new file mode 100755
index 0000000..37fa40c
--- /dev/null
+++ b/dlls/wineboxed.drv/wineboxed.c
@@ -0,0 +1,959 @@
+/*
+ * Boxedwine graphics driver initialisation functions
+ *
+ * Copyright 1996 Alexandre Julliard
+ * Copyright 2011012013 Ken Thomases for CodeWeavers, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc.1 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#pragma GCC diagnostic ignored "-Wreturn-type"
+#include "config.h"
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "wine/debug.h"
+#include "wine/gdi_driver.h"
+#include "winreg.h"
+
+#include "winuser.h"
+#include "winternl.h"
+#include "winnt.h"
+#include "shellapi.h"
+#include "imm.h"
+#include "ddk/imm.h"
+#include "wine/library.h"
+#include "wine/wgl.h"
+#include "wine/wgl_driver.h"
+#include "wine/wglext.h"
+#include "wine/unicode.h"
+#include "wine/server.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(boxeddrv);
+
+typedef struct
+{
+	struct gdi_physdev  dev;
+} BOXEDDRV_PDEVICE;
+
+#define BOXED_BASE 0
+
+#define BOXED_ACQUIRE_CLIPBOARD						(BOXED_BASE)
+#define BOXED_ACTIVATE_KEYBOARD_LAYOUT				(BOXED_BASE+1)
+#define BOXED_BEEP									(BOXED_BASE+2)
+#define BOXED_CHANGE_DISPLAY_SETTINGS_EX			(BOXED_BASE+3)
+#define BOXED_CLIP_CURSOR							(BOXED_BASE+4)
+#define BOXED_COUNT_CLIPBOARD_FORMATS				(BOXED_BASE+5)
+#define BOXED_CREATE_DESKTOP_WINDOW					(BOXED_BASE+6)
+#define BOXED_CREATE_WINDOW							(BOXED_BASE+7)
+#define BOXED_DESTROY_CURSOR_ICON					(BOXED_BASE+8)
+#define BOXED_DESTROY_WINDOW						(BOXED_BASE+9)
+#define BOXED_EMPTY_CLIPBOARD						(BOXED_BASE+10)
+#define BOXED_END_CLIPBOARD_UPDATE					(BOXED_BASE+11)
+#define BOXED_ENUM_CLIPBOARD_FORMATS				(BOXED_BASE+12)
+#define BOXED_ENUM_DISPLAY_MONITORS					(BOXED_BASE+13)
+#define BOXED_ENUM_DISPLAY_SETTINGS_EX				(BOXED_BASE+14)
+#define BOXED_GET_CLIPBOARD_DATA					(BOXED_BASE+15)
+#define BOXED_GET_CURSOR_POS						(BOXED_BASE+16)
+#define BOXED_GET_KEYBOARD_LAYOUT					(BOXED_BASE+17)
+#define BOXED_GET_KEYBOARD_LAYOUT_NAME				(BOXED_BASE+18)
+#define BOXED_GET_KEY_NAME							(BOXED_BASE+19)
+#define BOXED_GET_MONITOR_INFO						(BOXED_BASE+20)
+#define BOXED_IS_CLIPBOARD_FORMAT_AVAILABLE			(BOXED_BASE+21)
+#define BOXED_MAP_VIRTUAL_KEY_EX					(BOXED_BASE+22)
+#define BOXED_MSG_WAIT_FOR_MULTIPLE_OBJECTS_EX		(BOXED_BASE+23)
+#define BOXED_SET_CAPTURE							(BOXED_BASE+24)
+#define BOXED_SET_CLIPBOARD_DATA					(BOXED_BASE+25)
+#define BOXED_SET_CURSOR							(BOXED_BASE+26)
+#define BOXED_SET_CURSOR_POS						(BOXED_BASE+27)
+#define BOXED_SET_FOCUS								(BOXED_BASE+28)
+#define BOXED_SET_LAYERED_WINDOW_ATTRIBUTES			(BOXED_BASE+29)
+#define BOXED_SET_PARENT							(BOXED_BASE+30)
+#define BOXED_SET_WINDOW_RGN						(BOXED_BASE+31)
+#define BOXED_SET_WINDOW_STYLE						(BOXED_BASE+32)
+#define BOXED_SET_WINDOW_TEXT						(BOXED_BASE+33)
+#define BOXED_SHOW_WINDOW							(BOXED_BASE+34)
+#define BOXED_SYS_COMMAND							(BOXED_BASE+35)
+#define BOXED_SYSTEM_PARAMETERS_INFO				(BOXED_BASE+36)
+#define BOXED_TO_UNICODE_EX							(BOXED_BASE+37)
+#define BOXED_UPDATE_LAYERED_WINDOW					(BOXED_BASE+38)
+#define BOXED_VK_KEY_SCAN_EX						(BOXED_BASE+39)
+#define BOXED_WINDOW_MESSAGE						(BOXED_BASE+40)
+#define BOXED_WINDOW_POS_CHANGED					(BOXED_BASE+41)
+#define BOXED_WINDOW_POS_CHANGING					(BOXED_BASE+42)
+
+#define BOXED_GET_DEVICE_GAMMA_RAMP					(BOXED_BASE+43)
+#define BOXED_SET_DEVICE_GAMMA_RAMP					(BOXED_BASE+44)
+#define BOXED_GET_DEVICE_CAPS						(BOXED_BASE+45)
+
+#define BOXED_WINE_NOTIFY_ICON						(BOXED_BASE+46)
+
+#define BOXED_IME_CONFIGURE							(BOXED_BASE+47)
+#define BOXED_IME_CONVERSION_LIST					(BOXED_BASE+48)
+#define BOXED_IME_DESTROY							(BOXED_BASE+49)
+#define BOXED_IME_ENUM_REGISTER_WORD				(BOXED_BASE+50)
+#define BOXED_IME_ESCAPE							(BOXED_BASE+51)
+#define BOXED_IME_GET_IME_MENU_ITEMS				(BOXED_BASE+52)
+#define BOXED_IME_GET_REGISTER_WORD_STYLE			(BOXED_BASE+53)
+#define BOXED_IME_INQUIRE							(BOXED_BASE+54)
+#define BOXED_IME_PROCESS_KEY						(BOXED_BASE+55)
+#define BOXED_IME_REGISTER_WORD						(BOXED_BASE+56)
+#define BOXED_IME_SELECT							(BOXED_BASE+57)
+#define BOXED_IME_SET_ACTIVE_CONTEXT				(BOXED_BASE+58)
+#define BOXED_IME_SET_COMPOSITION_STRING			(BOXED_BASE+59)
+#define BOXED_IME_TO_ASCII_EX						(BOXED_BASE+60)
+#define BOXED_IME_UNREGISTER_WORD					(BOXED_BASE+61)
+#define BOXED_NOTIFY_IME							(BOXED_BASE+62)
+
+#define BOXED_GL_COPY_CONTEXT						(BOXED_BASE+63)
+#define BOXED_GL_CREATE_CONTEXT						(BOXED_BASE+64)
+#define BOXED_GL_DELETE_CONTEXT						(BOXED_BASE+65)
+#define BOXED_GL_DESCRIBE_PIXEL_FORMAT				(BOXED_BASE+66)
+#define BOXED_GL_GET_PIXEL_FORMAT					(BOXED_BASE+67)
+#define BOXED_GL_GET_PROC_ADDRESS					(BOXED_BASE+68)
+#define BOXED_GL_MAKE_CURRENT						(BOXED_BASE+69)
+#define BOXED_GL_SET_PIXEL_FORMAT					(BOXED_BASE+70)
+#define BOXED_GL_SHARE_LISTS						(BOXED_BASE+71)
+#define BOXED_GL_SWAP_BUFFERS						(BOXED_BASE+72)
+
+#define BOXED_GET_KEYBOARD_LAYOUT_LIST				(BOXED_BASE+73)
+#define BOXED_REGISTER_HOT_KEY						(BOXED_BASE+74)
+#define BOXED_UNREGISTER_HOT_KEY					(BOXED_BASE+75)
+#define BOXED_SET_SURFACE							(BOXED_BASE+76)
+#define BOXED_GET_SURFACE							(BOXED_BASE+77)
+#define BOXED_FLUSH_SURFACE							(BOXED_BASE+78)
+
+#define CALL_0(index) __asm__("push %0\n\tint $0x98\n\taddl $4, %%esp"::"i"(index):"%eax"); 
+#define CALL_1(index, arg1) __asm__("push %1\n\tpush %0\n\tint $0x98\n\taddl $8, %%esp"::"i"(index), "g"(arg1):"%eax"); 
+#define CALL_2(index, arg1,arg2) __asm__("push %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $12, %%esp"::"i"(index), "g"(arg1), "g"(arg2):"%eax");
+#define CALL_3(index, arg1,arg2,arg3) __asm__("push %3\n\tpush %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $16, %%esp"::"i"(index), "g"(arg1), "g"(arg2), "g"(arg3):"%eax");
+#define CALL_4(index, arg1,arg2,arg3,arg4) __asm__("push %4\n\tpush %3\n\tpush %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $20, %%esp"::"i"(index), "g"(arg1), "g"(arg2), "g"(arg3), "g"(arg4):"%eax");
+#define CALL_5(index, arg1,arg2,arg3,arg4,arg5) __asm__("push %5\n\tpush %4\n\tpush %3\n\tpush %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $24, %%esp"::"i"(index), "g"(arg1), "g"(arg2), "g"(arg3), "g"(arg4), "g"(arg5):"%eax");
+#define CALL_6(index, arg1,arg2,arg3,arg4,arg5,arg6) __asm__("push %6\n\tpush %5\n\tpush %4\n\tpush %3\n\tpush %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $28, %%esp"::"i"(index), "g"(arg1), "g"(arg2), "g"(arg3), "g"(arg4), "g"(arg5), "g"(arg6):"%eax");
+#define CALL_7(index, arg1,arg2,arg3,arg4,arg5,arg6,arg7) __asm__("push %7\n\tpush %6\n\tpush %5\n\tpush %4\n\tpush %3\n\tpush %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $32, %%esp"::"i"(index), "g"(arg1), "g"(arg2), "g"(arg3), "g"(arg4), "g"(arg5), "g"(arg6), "g"(arg7):"%eax");
+
+#define CALL_NORETURN_0(index) __asm__("push %0\n\tint $0x98\n\taddl $4, %%esp"::"i"(index)); 
+#define CALL_NORETURN_1(index, arg1) __asm__("push %1\n\tpush %0\n\tint $0x98\n\taddl $8, %%esp"::"i"(index), "g"(arg1)); 
+#define CALL_NORETURN_2(index, arg1, arg2) __asm__("push %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $12, %%esp"::"i"(index), "g"(arg1), "g"(arg2)); 
+#define CALL_NORETURN_3(index, arg1, arg2, arg3) __asm__("push %3\n\rpush %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $16, %%esp"::"i"(index), "g"(arg1), "g"(arg2), "g"(arg3)); 
+#define CALL_NORETURN_4(index, arg1, arg2, arg3, arg4) __asm__("push %4\n\tpush %3\n\rpush %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $20, %%esp"::"i"(index), "g"(arg1), "g"(arg2), "g"(arg3), "g"(arg4)); 
+#define CALL_NORETURN_5(index, arg1, arg2, arg3, arg4, arg5) __asm__("push %5\n\tpush %4\n\tpush %3\n\rpush %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $24, %%esp"::"i"(index), "g"(arg1), "g"(arg2), "g"(arg3), "g"(arg4), "g"(arg5)); 
+#define CALL_NORETURN_7(index, arg1,arg2,arg3,arg4,arg5,arg6,arg7) __asm__("push %7\n\tpush %6\n\tpush %5\n\tpush %4\n\tpush %3\n\tpush %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $32, %%esp"::"i"(index), "g"(arg1), "g"(arg2), "g"(arg3), "g"(arg4), "g"(arg5), "g"(arg6), "g"(arg7));
+#define CALL_NORETURN_8(index, arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8) __asm__("push %8\n\tpush %7\n\tpush %6\n\tpush %5\n\tpush %4\n\tpush %3\n\tpush %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $36, %%esp"::"i"(index), "g"(arg1), "g"(arg2), "g"(arg3), "g"(arg4), "g"(arg5), "g"(arg6), "g"(arg7), "g"(arg8));
+#define CALL_NORETURN_9(index, arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9) __asm__("push %9\n\tpush %8\n\tpush %7\n\tpush %6\n\tpush %5\n\tpush %4\n\tpush %3\n\tpush %2\n\tpush %1\n\tpush %0\n\tint $0x98\n\taddl $40, %%esp"::"i"(index), "g"(arg1), "g"(arg2), "g"(arg3), "g"(arg4), "g"(arg5), "g"(arg6), "g"(arg7), "g"(arg8), "g"(arg9));
+
+INT boxeddrv_GetDeviceCaps(PHYSDEV dev, INT cap);
+
+static inline BOOL can_activate_window(HWND hwnd)
+{
+    LONG style = GetWindowLongW(hwnd, GWL_STYLE);
+
+    if (!(style & WS_VISIBLE)) {
+        TRACE("not visible\n");
+        return FALSE;
+    }
+    if ((style & (WS_POPUP|WS_CHILD)) == WS_CHILD) {
+        TRACE("child or popup\n");
+        return FALSE;
+    }
+    if (GetWindowLongW(hwnd, GWL_EXSTYLE) & WS_EX_NOACTIVATE) {
+        TRACE("not activate\n");
+        return FALSE;
+    }
+    if (hwnd == GetDesktopWindow()) {
+        TRACE("desktop\n");
+        return FALSE;
+    }
+    if (style & WS_DISABLED) {
+        TRACE("disabled\n");
+    }
+    TRACE("yes\n");
+    return TRUE;
+}
+
+int CDECL boxeddrv_AcquireClipboard(HWND hwnd) {
+	TRACE("hwnd=%p\n", hwnd);
+	CALL_1(BOXED_ACQUIRE_CLIPBOARD, hwnd);
+}
+
+HKL CDECL boxeddrv_ActivateKeyboardLayout(HKL hkl, UINT flags) {
+	TRACE("hkl=%p flags=0x%08x\n", hkl, flags);
+	CALL_2(BOXED_ACTIVATE_KEYBOARD_LAYOUT, hkl, flags);
+}
+
+void CDECL boxeddrv_Beep(void) {
+	TRACE("\n");
+	CALL_NORETURN_0(BOXED_BEEP);
+}
+
+LONG CDECL boxeddrv_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode, HWND hwnd, DWORD flags, LPVOID lpvoid) {
+	TRACE("devname=%s devmode=%p hwnd=%p flags=0x%08x %p\n", debugstr_w(devname), devmode, hwnd, flags, lpvoid);
+	CALL_5(BOXED_CHANGE_DISPLAY_SETTINGS_EX, devname, devmode, hwnd, flags, lpvoid);
+}
+
+BOOL CDECL boxeddrv_ClipCursor(LPCRECT clip) {
+	TRACE("clip=%s\n", wine_dbgstr_rect(clip));
+	CALL_1(BOXED_CLIP_CURSOR, clip);
+}
+
+INT CDECL boxeddrv_CountClipboardFormats(void) {
+	TRACE("\n");
+	CALL_0(BOXED_COUNT_CLIPBOARD_FORMATS);
+}
+
+void initDesktop(HWND hwnd) {
+    unsigned int width, height;
+
+    TRACE("%p\n", hwnd);
+
+    /* retrieve the real size of the desktop */
+    SERVER_START_REQ(get_window_rectangles)
+    {
+        req->handle = wine_server_user_handle(hwnd);
+        req->relative = COORDS_CLIENT;
+        wine_server_call(req);
+        width  = reply->window.right;
+        height = reply->window.bottom;
+    }
+    SERVER_END_REQ;
+
+    if (!width && !height)  /* not initialized yet */
+    {
+        width = boxeddrv_GetDeviceCaps(NULL, DESKTOPHORZRES); 
+		height = boxeddrv_GetDeviceCaps(NULL, DESKTOPVERTRES);
+
+        SERVER_START_REQ(set_window_pos)
+        {
+            req->handle        = wine_server_user_handle(hwnd);
+            req->previous      = 0;
+            req->swp_flags     = SWP_NOZORDER;
+            req->window.left   = 0;
+            req->window.top    = 0;
+            req->window.right  = width;
+            req->window.bottom = height;
+            req->client        = req->window;
+            wine_server_call(req);
+        }
+        SERVER_END_REQ;
+    }
+}
+BOOL CDECL boxeddrv_CreateDesktopWindow(HWND hwnd) {
+	CALL_1(BOXED_CREATE_DESKTOP_WINDOW, hwnd);
+	initDesktop(hwnd);
+	return TRUE;
+}
+
+BOOL CDECL boxeddrv_CreateWindow(HWND hwnd) {
+	TRACE("hwnd=%p\n", hwnd);
+	CALL_1(BOXED_CREATE_WINDOW, hwnd);
+}
+
+void CDECL boxeddrv_DestroyCursorIcon(HCURSOR cursor) {
+	TRACE("cursor=%p\n", cursor);
+	CALL_NORETURN_1(BOXED_DESTROY_CURSOR_ICON, cursor);
+}
+
+void CDECL boxeddrv_DestroyWindow(HWND hwnd) {
+	TRACE("hwnd=%p\n", hwnd);
+	CALL_NORETURN_1(BOXED_DESTROY_WINDOW, hwnd);
+}
+
+void CDECL boxeddrv_EmptyClipboard(BOOL keepunowned) {
+	TRACE("keepunowned=%d\n", keepunowned);
+	CALL_NORETURN_1(BOXED_EMPTY_CLIPBOARD, keepunowned);
+}
+
+void CDECL boxeddrv_EndClipboardUpdate(void) {
+	TRACE("\n");
+	CALL_NORETURN_0(BOXED_END_CLIPBOARD_UPDATE);
+}
+
+UINT CDECL boxeddrv_EnumClipboardFormats(UINT prev_format) {
+	TRACE("prev_format=%d\n", prev_format);
+	CALL_1(BOXED_ENUM_CLIPBOARD_FORMATS, prev_format);
+}
+
+INT boxeddrv_GetDeviceCaps(PHYSDEV dev, INT cap);
+BOOL CDECL boxeddrv_EnumDisplayMonitors(HDC hdc, LPRECT rect, MONITORENUMPROC proc, LPARAM lparam) {
+	RECT r;
+	r.left = 0;
+	r.right = boxeddrv_GetDeviceCaps(0, HORZRES);
+	r.top = 0;
+	r.bottom = boxeddrv_GetDeviceCaps(0, VERTRES);
+
+	TRACE("hdc=%p rect=%s proc=%p lparam=0x%08x\n", hdc, wine_dbgstr_rect(rect), proc, (int)lparam);
+	if (hdc) {
+		POINT origin;
+		RECT limit;
+		RECT monrect = r;
+
+		if (!GetDCOrgEx(hdc, &origin)) return FALSE;
+		if (GetClipBox(hdc, &limit) == ERROR) return FALSE;
+
+		if (rect && !IntersectRect(&limit, &limit, rect)) return TRUE;
+
+		if (IntersectRect(&monrect, &monrect, &limit)) {
+			if (!proc((HMONITOR)1, hdc, &monrect, lparam))
+				return FALSE;
+		}
+	}
+	else {
+		RECT monrect = r;
+		RECT unused;
+
+		if (!rect || IntersectRect(&unused, &monrect, rect)) {
+            TRACE("calling proc hdc=%p monrect=%s proc=%p lparam=0x%08x\n", hdc, wine_dbgstr_rect(&monrect), proc, (int)lparam);
+			if (!proc((HMONITOR)1, hdc, &monrect, lparam))
+				return FALSE;
+		}
+	}
+	
+	return TRUE;
+}
+
+BOOL CDECL boxeddrv_EnumDisplaySettingsEx(LPCWSTR devname, DWORD mode, LPDEVMODEW devmode, DWORD flags) {
+	TRACE("devname=%s mode=%d devmode=%p flags=0x%08x\n", debugstr_w(devname), mode, devmode, flags);
+	CALL_4(BOXED_ENUM_DISPLAY_SETTINGS_EX, devname, mode, devmode, flags);
+}
+
+HANDLE CDECL boxeddrv_GetClipboardData(UINT desired_format) {
+	TRACE("desired_format=%d\n", desired_format);
+	CALL_1(BOXED_GET_CLIPBOARD_DATA, desired_format);
+}
+
+BOOL CDECL boxeddrv_GetCursorPos(LPPOINT pos) {
+	TRACE("pos=%p\n", pos);
+	CALL_1(BOXED_GET_CURSOR_POS, pos);
+}
+
+HKL CDECL boxeddrv_GetKeyboardLayout(DWORD thread_id) {
+	TRACE("thread_id=%d\n", thread_id);
+	CALL_1(BOXED_GET_KEYBOARD_LAYOUT, thread_id);
+}
+
+BOOL CDECL boxeddrv_GetKeyboardLayoutName(LPWSTR name) {
+	TRACE("name=%s\n", debugstr_w(name));
+	CALL_1(BOXED_GET_KEYBOARD_LAYOUT_NAME, name);
+}
+
+INT CDECL boxeddrv_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size) {
+	TRACE("lparam=0x%08x buffer=%p size=%d\n", lparam, buffer, size);
+	CALL_3(BOXED_GET_KEY_NAME, lparam, buffer, size);
+}
+
+BOOL CDECL boxeddrv_GetMonitorInfo(HMONITOR monitor, LPMONITORINFO info) {
+    static const WCHAR adapter_name[] = { '\\','\\','.','\\','D','I','S','P','L','A','Y','1',0 };
+
+	TRACE("monitor=%p info=%p\n", monitor, info);
+    SetRect(&info->rcMonitor, 0, 0, boxeddrv_GetDeviceCaps(NULL, DESKTOPHORZRES), boxeddrv_GetDeviceCaps(NULL, DESKTOPVERTRES));
+    SetRect(&info->rcWork, 0, 0, boxeddrv_GetDeviceCaps(NULL, DESKTOPHORZRES), boxeddrv_GetDeviceCaps(NULL, DESKTOPVERTRES));
+    info->dwFlags = MONITORINFOF_PRIMARY;
+
+    if (info->cbSize >= sizeof(MONITORINFOEXW))
+        lstrcpyW(((MONITORINFOEXW*)info)->szDevice, adapter_name);
+    return TRUE;
+	//CALL_2(BOXED_GET_MONITOR_INFO, monitor, info);
+}
+
+BOOL CDECL boxeddrv_IsClipboardFormatAvailable(UINT desired_format) {
+	TRACE("desired_format=%d\n", desired_format);
+	CALL_1(BOXED_IS_CLIPBOARD_FORMAT_AVAILABLE, desired_format);
+}
+
+UINT CDECL boxeddrv_MapVirtualKeyEx(UINT wCode, UINT wMapType, HKL hkl) {
+	TRACE("wCode=%d wMapType=%d hkl=%p\n", wCode, wMapType, hkl);
+	CALL_3(BOXED_MAP_VIRTUAL_KEY_EX, wCode, wMapType, hkl);
+}
+
+DWORD CDECL boxeddrv_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles, DWORD timeout, DWORD mask, DWORD flags) {
+	TRACE("count=%d handles=%p timeout=0x%08x mask=0x%08x flags=0x%08x\n", count, handles, timeout, mask, flags);
+    CALL_5(BOXED_MSG_WAIT_FOR_MULTIPLE_OBJECTS_EX, count, handles, timeout, mask, flags);
+    if (!count && !timeout) return WAIT_TIMEOUT;
+        return WaitForMultipleObjectsEx(count, handles, flags & MWMO_WAITALL, timeout, flags & MWMO_ALERTABLE);	
+}
+
+void CDECL boxeddrv_SetCapture(HWND hwnd, UINT flags) {
+	TRACE("hwnd=%p flags=0x%08x\n", hwnd, flags);
+	CALL_NORETURN_2(BOXED_SET_CAPTURE, hwnd, flags);
+}
+
+BOOL CDECL boxeddrv_SetClipboardData(UINT format_id, HANDLE data, BOOL owner) {
+	TRACE("format_id=%d data=%p owner=%d\n", format_id, data, owner);
+	CALL_3(BOXED_SET_CLIPBOARD_DATA, format_id, data, owner);
+}
+
+void CDECL boxeddrv_SetCursor(HCURSOR cursor) {
+	TRACE("cursor=%p\n", cursor);
+	CALL_NORETURN_1(BOXED_SET_CURSOR, cursor);
+}
+
+BOOL CDECL boxeddrv_SetCursorPos(INT x, INT y) {
+	TRACE("x=%d y=%d\n", x, y);
+	CALL_2(BOXED_SET_CURSOR_POS, x, y);
+}
+
+void CDECL boxeddrv_SetFocus(HWND hwnd) {
+    LONG style = GetWindowLongW(hwnd, GWL_STYLE);
+    BOOL canSetFocus = FALSE;
+
+	TRACE("hwnd=%p\n", hwnd);	
+    CALL_NORETURN_2(BOXED_SET_FOCUS, hwnd, &canSetFocus);
+
+    if (!hwnd || !canSetFocus) return;
+
+    if (can_activate_window(hwnd) && !(style & WS_MINIMIZE))
+    {
+        // simulate a mouse click on the caption to find out whether the window wants to be activated 
+        LRESULT ma = SendMessageW(hwnd, WM_MOUSEACTIVATE, (WPARAM)GetAncestor(hwnd, GA_ROOT), MAKELONG(HTCAPTION,WM_LBUTTONDOWN));
+        if (ma != MA_NOACTIVATEANDEAT && ma != MA_NOACTIVATE)
+        {
+            TRACE("setting foreground window to %p\n", hwnd);            
+            SetForegroundWindow(hwnd);            
+        }
+    }
+}
+
+void CDECL boxeddrv_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags) {
+	TRACE("hwnd=%p key=0x%08x alpha=0x%02x flags=0x%08x\n", hwnd, key, alpha, flags);
+	CALL_NORETURN_4(BOXED_SET_LAYERED_WINDOW_ATTRIBUTES, hwnd, key, alpha, flags);
+}
+
+void CDECL boxeddrv_SetParent(HWND hwnd, HWND parent, HWND old_parent) {
+	TRACE("hwnd=%p parent=%p old_parent=%p\n", hwnd, parent, old_parent);
+	CALL_NORETURN_3(BOXED_SET_PARENT, hwnd, parent, old_parent);
+}
+
+int CDECL boxeddrv_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) {
+	TRACE("hwnd=%p hrgn=%p redraw=%d\n", hwnd, hrgn, redraw);
+	CALL_3(BOXED_SET_WINDOW_RGN, hwnd, hrgn, redraw);
+}
+
+void CDECL boxeddrv_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) {
+	TRACE("hwnd=%p offset=%d style=%p\n", hwnd, offset, style);
+	CALL_NORETURN_3(BOXED_SET_WINDOW_STYLE, hwnd, offset, style);
+}
+
+void CDECL boxeddrv_SetWindowText(HWND hwnd, LPCWSTR text) {
+	TRACE("hwnd=%p text=%s\n", hwnd, debugstr_w(text));
+	CALL_NORETURN_2(BOXED_SET_WINDOW_TEXT, hwnd, text);
+}
+
+UINT CDECL boxeddrv_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) {
+    HWND hwndFocus;
+    UINT result;
+
+	TRACE("hwnd=%p cmd=%d rect=%s swp=0x%08x\n", hwnd, cmd, wine_dbgstr_rect(rect), swp);
+    if (IsRectEmpty(rect)) return swp;
+	CALL_NORETURN_5(BOXED_SHOW_WINDOW, hwnd, cmd, rect, swp, &result);    
+    hwndFocus = GetFocus();
+    if (hwndFocus && (hwnd == hwndFocus || IsChild(hwnd, hwndFocus)))
+        boxeddrv_SetFocus(hwnd);
+    return result;
+}
+
+LRESULT CDECL boxeddrv_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) {
+	TRACE("hwnd=%p wparam=0x%08x lparam=0x%08x\n", hwnd, (int)wparam, (int)lparam);
+	CALL_3(BOXED_SYS_COMMAND, hwnd, wparam, lparam);
+}
+
+BOOL CDECL boxeddrv_SystemParametersInfo(UINT action, UINT int_param, void *ptr_param, UINT flags) {
+	TRACE("action=%d int_param=%d ptr_param=%p flags=0x%08x\n", action, int_param, ptr_param, flags);
+	CALL_4(BOXED_SYSTEM_PARAMETERS_INFO, action, int_param, ptr_param, flags);
+}
+
+INT CDECL boxeddrv_ToUnicodeEx(UINT virtKey, UINT scanCode, const BYTE *lpKeyState, LPWSTR bufW, int bufW_size, UINT flags, HKL hkl) {
+	CALL_7(BOXED_TO_UNICODE_EX, virtKey, scanCode, lpKeyState, bufW, bufW_size, flags, hkl);
+}
+
+BOOL CDECL boxeddrv_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info, const RECT *window_rect) {
+	CALL_3(BOXED_UPDATE_LAYERED_WINDOW, hwnd, info, window_rect);
+}
+
+SHORT CDECL boxeddrv_VkKeyScanEx(WCHAR wChar, HKL hkl) {
+	CALL_2(BOXED_VK_KEY_SCAN_EX, wChar, hkl);
+}
+
+LRESULT CDECL boxeddrv_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) {
+	CALL_4(BOXED_WINDOW_MESSAGE, hwnd, msg, wp, lp);
+}
+
+void boxeddrv_SetSurface(HWND hwnd, struct window_surface *surface) {
+	CALL_NORETURN_2(BOXED_SET_SURFACE, hwnd, surface);
+}
+
+struct window_surface* boxeddrv_GetSurface(HWND hwnd) {
+	CALL_1(BOXED_GET_SURFACE, hwnd);
+}
+
+void CDECL boxeddrv_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags, const RECT *window_rect, const RECT *client_rect, const RECT *visible_rect, const RECT *valid_rects, struct window_surface *surface) {
+	DWORD new_style = GetWindowLongW(hwnd, GWL_STYLE);
+    struct window_surface* oldSurface = boxeddrv_GetSurface(hwnd);
+
+	TRACE("hwnd=%p insert_after=%p swp_flags=0x%08x window_rect=%s client_rect=%s visible_rect=%s valid_rects=%s surface=%p style=0x%08x\n", hwnd, insert_after, swp_flags, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect), wine_dbgstr_rect(visible_rect), wine_dbgstr_rect(valid_rects), surface, new_style);
+    if (surface) {
+        TRACE("     using new surface %p (ref=%d)\n", surface, surface->ref);
+        window_surface_add_ref(surface);
+    }
+    if (oldSurface) {
+        TRACE("     releasing old surface %p (ref=%d)\n", oldSurface, oldSurface->ref);
+        window_surface_release(oldSurface);
+    }
+	boxeddrv_SetSurface(hwnd, surface);	
+	CALL_NORETURN_8(BOXED_WINDOW_POS_CHANGED, hwnd, insert_after, swp_flags, window_rect, client_rect, visible_rect, valid_rects, new_style);
+}
+
+void surface_clip_to_visible_rect(struct window_surface *window_surface, const RECT *visible_rect);
+struct window_surface *create_surface(HWND window, const RECT *rect, struct window_surface *old_surface, BOOL use_alpha);
+void CDECL boxeddrv_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags, const RECT *window_rect, const RECT *client_rect, RECT *visible_rect, struct window_surface **surface) {
+    DWORD style = GetWindowLongW(hwnd, GWL_STYLE); 
+    struct window_surface *oldSurface = NULL;
+    HWND parent = GetAncestor(hwnd, GA_PARENT);
+
+	TRACE("hwnd=%p (parent=%p) insert_after=%p swp_flags=0x%08x window_rect=%s client_rect=%s visible_rect=%s surface=%p\n", hwnd, parent, insert_after, swp_flags, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect), wine_dbgstr_rect(visible_rect), surface);     
+
+    if (GetWindowThreadProcessId(hwnd, NULL) != GetCurrentThreadId()) return;
+
+    if (!parent)  /* desktop */
+    {
+        return;
+    }
+
+    /* don't create wnd for HWND_MESSAGE windows */
+    if (parent != GetDesktopWindow() && !GetAncestor(parent, GA_PARENT)) return;
+    
+    if (*surface)  {
+        oldSurface = *surface;
+        TRACE("     setting old surface %p (ref=%d)\n", *surface, (*surface)->ref);
+    }
+    *surface = NULL;
+    
+    *visible_rect = *window_rect;
+    if (swp_flags & SWP_HIDEWINDOW) return;    
+	CALL_NORETURN_7(BOXED_WINDOW_POS_CHANGING, hwnd, insert_after, swp_flags, window_rect, client_rect, visible_rect, surface);
+
+    if (parent != GetDesktopWindow()) {
+        return; // don't create surface
+    }
+	if (*surface) {
+        int surfaceWidth = (*surface)->rect.right - (*surface)->rect.left;
+        int surfaceHeight = (*surface)->rect.bottom - (*surface)->rect.top;
+        int windowWidth = window_rect->right - window_rect->left;
+        int windowHeight = window_rect->bottom - window_rect->top;
+
+        if (oldSurface)  {
+            TRACE("     releasing old surface %p (ref=%d)\n", oldSurface, oldSurface->ref);
+            window_surface_release(oldSurface);
+        }
+        TRACE("     checking existing surface %p (ref=%d)\n", *surface, (*surface)->ref);
+        if (surfaceWidth==windowWidth && surfaceHeight==windowHeight) {
+		    // use existing surface
+		    surface_clip_to_visible_rect(*surface, visible_rect);
+            window_surface_add_ref(*surface);
+            return;
+        }
+    }
+    if (oldSurface)  {
+        TRACE("     releasing old surface %p (ref=%d)\n", oldSurface, oldSurface->ref);
+        window_surface_release(oldSurface);
+    }
+	if ((swp_flags & SWP_SHOWWINDOW) || (style & WS_VISIBLE)) {
+		*surface = create_surface(hwnd, window_rect, *surface, FALSE);
+        TRACE("     created new surface %p (ref=%d)\n", *surface, (*surface)->ref);
+	}
+}
+
+void boxeddrv_FlushSurface(HWND hwnd, void* bits, int xOrg, int yOrg, int width, int height, RECT* rect, RECT* rects, int rectCount) {
+	TRACE("hwnd=%p bits=%p width=%d height=%d rect=%s rects=%p rectCount=%d\n", hwnd, bits, width, height, wine_dbgstr_rect(rect), rects, rectCount);
+	CALL_NORETURN_9(BOXED_FLUSH_SURFACE, hwnd, bits, xOrg, yOrg, width, height, rect, rects, rectCount);
+}
+
+BOOL boxeddrv_GetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp) {
+	TRACE("dev=%p ramp=%p\n", dev, ramp);
+	CALL_2(BOXED_GET_DEVICE_GAMMA_RAMP, dev, ramp);
+}
+
+BOOL boxeddrv_SetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp) {
+	TRACE("dev=%p ramp=%p\n", dev, ramp);
+	CALL_2(BOXED_SET_DEVICE_GAMMA_RAMP, dev, ramp);
+}
+
+INT boxeddrv_GetDeviceCaps(PHYSDEV dev, INT cap) {
+	TRACE("dev=%p cap=%d\n", dev, cap);
+	switch (cap) {
+	case PDEVICESIZE:
+		return sizeof(BOXEDDRV_PDEVICE);
+	}
+	CALL_2(BOXED_GET_DEVICE_CAPS, dev, cap);
+}
+
+int CDECL wine_notify_icon(DWORD msg, NOTIFYICONDATAW *data) {
+	CALL_2(BOXED_WINE_NOTIFY_ICON, msg, data);
+}
+
+BOOL WINAPI ImeConfigure(HKL hKL, HWND hWnd, DWORD dwMode, LPVOID lpData) {
+	CALL_4(BOXED_IME_CONFIGURE, hKL, hWnd, dwMode, lpData);
+}
+
+DWORD WINAPI ImeConversionList(HIMC hIMC, LPCWSTR lpSource, LPCANDIDATELIST lpCandList, DWORD dwBufLen, UINT uFlag) {
+	CALL_5(BOXED_IME_CONVERSION_LIST, hIMC, lpSource, lpCandList, dwBufLen, uFlag);
+}
+
+BOOL WINAPI ImeDestroy(UINT uForce) {
+	CALL_1(BOXED_IME_DESTROY, uForce);
+}
+
+UINT WINAPI ImeEnumRegisterWord(REGISTERWORDENUMPROCW lpfnEnumProc, LPCWSTR lpszReading, DWORD dwStyle, LPCWSTR lpszRegister, LPVOID lpData) {
+	CALL_5(BOXED_IME_ENUM_REGISTER_WORD, lpfnEnumProc, lpszReading, dwStyle, lpszRegister, lpData);
+}
+
+LRESULT WINAPI ImeEscape(HIMC hIMC, UINT uSubFunc, LPVOID lpData) {
+	CALL_3(BOXED_IME_ESCAPE, hIMC, uSubFunc, lpData);
+}
+
+DWORD WINAPI ImeGetImeMenuItems(HIMC hIMC, DWORD dwFlags, DWORD dwType, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize) {
+	CALL_6(BOXED_IME_GET_IME_MENU_ITEMS, hIMC, dwFlags, dwType, lpImeParentMenu, lpImeMenu, dwSize);
+}
+
+UINT WINAPI ImeGetRegisterWordStyle(UINT nItem, LPSTYLEBUFW lpStyleBuf) {
+	CALL_2(BOXED_IME_GET_REGISTER_WORD_STYLE, nItem, lpStyleBuf);
+}
+
+BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo, LPWSTR lpszUIClass, LPCWSTR lpszOption) {
+	CALL_3(BOXED_IME_INQUIRE, lpIMEInfo, lpszUIClass, lpszOption);
+}
+
+BOOL WINAPI ImeProcessKey(HIMC hIMC, UINT vKey, LPARAM lKeyData, const LPBYTE lpbKeyState) {
+	CALL_4(BOXED_IME_PROCESS_KEY, hIMC, vKey, lKeyData, lpbKeyState);
+}
+
+BOOL WINAPI ImeRegisterWord(LPCWSTR lpszReading, DWORD dwStyle, LPCWSTR lpszRegister) {
+	CALL_3(BOXED_IME_REGISTER_WORD, lpszReading, dwStyle, lpszRegister);
+}
+
+BOOL WINAPI ImeSelect(HIMC hIMC, BOOL fSelect) {
+	CALL_2(BOXED_IME_SELECT, hIMC, fSelect);
+}
+
+BOOL WINAPI ImeSetActiveContext(HIMC hIMC, BOOL fFlag) {
+	CALL_2(BOXED_IME_SET_ACTIVE_CONTEXT, hIMC, fFlag);
+}
+
+BOOL WINAPI ImeSetCompositionString(HIMC hIMC, DWORD dwIndex, LPCVOID lpComp, DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen) {
+	CALL_6(BOXED_IME_SET_COMPOSITION_STRING, hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
+}
+
+UINT WINAPI ImeToAsciiEx(UINT uVKey, UINT uScanCode, const LPBYTE lpbKeyState, LPDWORD lpdwTransKey, UINT fuState, HIMC hIMC) {
+	CALL_6(BOXED_IME_TO_ASCII_EX, uVKey, uScanCode, lpbKeyState, lpdwTransKey, fuState, hIMC);
+}
+
+BOOL WINAPI ImeUnregisterWord(LPCWSTR lpszReading, DWORD dwStyle, LPCWSTR lpszUnregister) {
+	CALL_3(BOXED_IME_UNREGISTER_WORD, lpszReading, dwStyle, lpszUnregister);
+}
+
+BOOL WINAPI NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue) {
+	CALL_4(BOXED_NOTIFY_IME, hIMC, dwAction, dwIndex, dwValue);
+}
+
+static BOOL boxeddrv_wglCopyContext(struct wgl_context *src, struct wgl_context *dst, UINT mask) {
+	CALL_3(BOXED_GL_COPY_CONTEXT, src, dst, mask);
+}
+
+static struct wgl_context *boxeddrv_wglCreateContext(HDC hdc) {
+	CALL_1(BOXED_GL_CREATE_CONTEXT, hdc);
+}
+
+static void boxeddrv_wglDeleteContext(struct wgl_context *context) {
+	CALL_NORETURN_1(BOXED_GL_DELETE_CONTEXT, context);
+}
+
+static int boxeddrv_wglDescribePixelFormat(HDC hdc, int fmt, UINT size, PIXELFORMATDESCRIPTOR *descr) {
+	CALL_4(BOXED_GL_DESCRIBE_PIXEL_FORMAT, hdc, fmt, size, descr);
+}
+
+static int boxeddrv_wglGetPixelFormat(HDC hdc) {
+	CALL_1(BOXED_GL_GET_PIXEL_FORMAT, hdc);
+}
+
+static PROC boxeddrv_wglGetProcAddress(const char *proc) {
+	CALL_1(BOXED_GL_GET_PROC_ADDRESS, proc);
+}
+
+static BOOL boxeddrv_wglMakeCurrent(HDC hdc, struct wgl_context *context) {
+	CALL_2(BOXED_GL_MAKE_CURRENT, hdc, context);
+}
+
+static BOOL boxeddrv_wglSetPixelFormat(HDC hdc, int fmt, const PIXELFORMATDESCRIPTOR *descr) {
+	CALL_3(BOXED_GL_SET_PIXEL_FORMAT, hdc, fmt, descr);
+}
+
+static BOOL boxeddrv_wglShareLists(struct wgl_context *org, struct wgl_context *dest) {
+	CALL_2(BOXED_GL_SHARE_LISTS, org, dest);
+}
+
+static BOOL boxeddrv_wglSwapBuffers(HDC hdc) {
+	CALL_1(BOXED_GL_SWAP_BUFFERS, hdc);
+}
+
+UINT CDECL boxeddrv_GetKeyboardLayoutList(INT size, HKL *list) {
+	CALL_2(BOXED_GET_KEYBOARD_LAYOUT_LIST, size, list);
+}
+
+BOOL CDECL boxeddrv_RegisterHotKey(HWND hwnd, UINT mod_flags, UINT vkey) {
+	CALL_3(BOXED_REGISTER_HOT_KEY, hwnd, mod_flags, vkey);
+}
+
+void CDECL boxeddrv_UnregisterHotKey(HWND hwnd, UINT modifiers, UINT vkey) {
+	CALL_NORETURN_3(BOXED_UNREGISTER_HOT_KEY, hwnd, modifiers, vkey);
+}
+
+static struct opengl_funcs opengl_funcs =
+{
+	{
+		boxeddrv_wglCopyContext,          /* p_wglCopyContext */
+		boxeddrv_wglCreateContext,        /* p_wglCreateContext */
+		boxeddrv_wglDeleteContext,        /* p_wglDeleteContext */
+		boxeddrv_wglDescribePixelFormat,  /* p_wglDescribePixelFormat */
+		boxeddrv_wglGetPixelFormat,       /* p_wglGetPixelFormat */
+		boxeddrv_wglGetProcAddress,       /* p_wglGetProcAddress */
+		boxeddrv_wglMakeCurrent,          /* p_wglMakeCurrent */
+		boxeddrv_wglSetPixelFormat,       /* p_wglSetPixelFormat */
+		boxeddrv_wglShareLists,           /* p_wglShareLists */
+		boxeddrv_wglSwapBuffers,          /* p_wglSwapBuffers */
+	}
+};
+
+/**********************************************************************
+*              macdrv_wine_get_wgl_driver
+*/
+struct opengl_funcs *boxeddrv_wine_get_wgl_driver(PHYSDEV dev, UINT version)
+{
+	if (version != WINE_WGL_DRIVER_VERSION)
+	{
+		ERR("version mismatch, opengl32 wants %u but boxeddrv has %u\n", version, WINE_WGL_DRIVER_VERSION);
+		return NULL;
+	}
+
+	return &opengl_funcs;
+}
+
+static inline BOXEDDRV_PDEVICE *get_boxeddrv_dev(PHYSDEV dev)
+{
+	return (BOXEDDRV_PDEVICE*)dev;
+}
+
+static BOXEDDRV_PDEVICE *create_boxed_physdev(void)
+{
+	return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(BOXEDDRV_PDEVICE));
+}
+
+
+/**********************************************************************
+*              DeleteDC (BOXEDDRV.@)
+*/
+static BOOL boxeddrv_DeleteDC(PHYSDEV dev)
+{
+	BOXEDDRV_PDEVICE *physDev = get_boxeddrv_dev(dev);
+
+	TRACE("hdc %p\n", dev->hdc);
+
+	HeapFree(GetProcessHeap(), 0, physDev);
+	return TRUE;
+}
+
+static BOOL boxeddrv_CreateDC(PHYSDEV *pdev, LPCWSTR driver, LPCWSTR device, LPCWSTR output, const DEVMODEW* initData);
+static BOOL boxeddrv_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev);
+
+static const struct gdi_dc_funcs boxeddrv_funcs =
+{
+    NULL,                                   /* pAbortDoc */
+    NULL,                                   /* pAbortPath */
+    NULL,                                   /* pAlphaBlend */
+    NULL,                                   /* pAngleArc */
+    NULL,                                   /* pArc */
+    NULL,                                   /* pArcTo */
+    NULL,                                   /* pBeginPath */
+    NULL,                                   /* pBlendImage */
+    NULL,                                   /* pChord */
+    NULL,                                   /* pCloseFigure */
+    boxeddrv_CreateCompatibleDC,            /* pCreateCompatibleDC */
+    boxeddrv_CreateDC,                      /* pCreateDC */
+    boxeddrv_DeleteDC,                      /* pDeleteDC */
+    NULL,                                   /* pDeleteObject */
+    NULL,                                   /* pDeviceCapabilities */
+    NULL,                                   /* pEllipse */
+    NULL,                                   /* pEndDoc */
+    NULL,                                   /* pEndPage */
+    NULL,                                   /* pEndPath */
+    NULL,                                   /* pEnumFonts */
+    NULL,                                   /* pEnumICMProfiles */
+    NULL,                                   /* pExcludeClipRect */
+    NULL,                                   /* pExtDeviceMode */
+    NULL,                                   /* pExtEscape */
+    NULL,                                   /* pExtFloodFill */
+    NULL,                                   /* pExtSelectClipRgn */
+    NULL,                                   /* pExtTextOut */
+    NULL,                                   /* pFillPath */
+    NULL,                                   /* pFillRgn */
+    NULL,                                   /* pFlattenPath */
+    NULL,                                   /* pFontIsLinked */
+    NULL,                                   /* pFrameRgn */
+    NULL,                                   /* pGdiComment */
+    NULL,                                   /* pGetBoundsRect */
+    NULL,                                   /* pGetCharABCWidths */
+    NULL,                                   /* pGetCharABCWidthsI */
+    NULL,                                   /* pGetCharWidth */
+    boxeddrv_GetDeviceCaps,                 /* pGetDeviceCaps */
+    boxeddrv_GetDeviceGammaRamp,            /* pGetDeviceGammaRamp */
+    NULL,                                   /* pGetFontData */
+    NULL,                                   /* pGetFontRealizationInfo */
+    NULL,                                   /* pGetFontUnicodeRanges */
+    NULL,                                   /* pGetGlyphIndices */
+    NULL,                                   /* pGetGlyphOutline */
+    NULL,                                   /* pGetICMProfile */
+    NULL,                                   /* pGetImage */
+    NULL,                                   /* pGetKerningPairs */
+    NULL,                                   /* pGetNearestColor */
+    NULL,                                   /* pGetOutlineTextMetrics */
+    NULL,                                   /* pGetPixel */
+    NULL,                                   /* pGetSystemPaletteEntries */
+    NULL,                                   /* pGetTextCharsetInfo */
+    NULL,                                   /* pGetTextExtentExPoint */
+    NULL,                                   /* pGetTextExtentExPointI */
+    NULL,                                   /* pGetTextFace */
+    NULL,                                   /* pGetTextMetrics */
+    NULL,                                   /* pGradientFill */
+    NULL,                                   /* pIntersectClipRect */
+    NULL,                                   /* pInvertRgn */
+    NULL,                                   /* pLineTo */
+    NULL,                                   /* pModifyWorldTransform */
+    NULL,                                   /* pMoveTo */
+    NULL,                                   /* pOffsetClipRgn */
+    NULL,                                   /* pOffsetViewportOrg */
+    NULL,                                   /* pOffsetWindowOrg */
+    NULL,                                   /* pPaintRgn */
+    NULL,                                   /* pPatBlt */
+    NULL,                                   /* pPie */
+    NULL,                                   /* pPolyBezier */
+    NULL,                                   /* pPolyBezierTo */
+    NULL,                                   /* pPolyDraw */
+    NULL,                                   /* pPolyPolygon */
+    NULL,                                   /* pPolyPolyline */
+    NULL,                                   /* pPolygon */
+    NULL,                                   /* pPolyline */
+    NULL,                                   /* pPolylineTo */
+    NULL,                                   /* pPutImage */
+    NULL,                                   /* pRealizeDefaultPalette */
+    NULL,                                   /* pRealizePalette */
+    NULL,                                   /* pRectangle */
+    NULL,                                   /* pResetDC */
+    NULL,                                   /* pRestoreDC */
+    NULL,                                   /* pRoundRect */
+    NULL,                                   /* pSaveDC */
+    NULL,                                   /* pScaleViewportExt */
+    NULL,                                   /* pScaleWindowExt */
+    NULL,                                   /* pSelectBitmap */
+    NULL,                                   /* pSelectBrush */
+    NULL,                                   /* pSelectClipPath */
+    NULL,                                   /* pSelectFont */
+    NULL,                                   /* pSelectPalette */
+    NULL,                                   /* pSelectPen */
+    NULL,                                   /* pSetArcDirection */
+    NULL,                                   /* pSetBkColor */
+    NULL,                                   /* pSetBkMode */
+    NULL,                                   /* pSetBoundsRect */
+    NULL,                                   /* pSetDCBrushColor */
+    NULL,                                   /* pSetDCPenColor */
+    NULL,                                   /* pSetDIBitsToDevice */
+    NULL,                                   /* pSetDeviceClipping */
+    boxeddrv_SetDeviceGammaRamp,            /* pSetDeviceGammaRamp */
+    NULL,                                   /* pSetLayout */
+    NULL,                                   /* pSetMapMode */
+    NULL,                                   /* pSetMapperFlags */
+    NULL,                                   /* pSetPixel */
+    NULL,                                   /* pSetPolyFillMode */
+    NULL,                                   /* pSetROP2 */
+    NULL,                                   /* pSetRelAbs */
+    NULL,                                   /* pSetStretchBltMode */
+    NULL,                                   /* pSetTextAlign */
+    NULL,                                   /* pSetTextCharacterExtra */
+    NULL,                                   /* pSetTextColor */
+    NULL,                                   /* pSetTextJustification */
+    NULL,                                   /* pSetViewportExt */
+    NULL,                                   /* pSetViewportOrg */
+    NULL,                                   /* pSetWindowExt */
+    NULL,                                   /* pSetWindowOrg */
+    NULL,                                   /* pSetWorldTransform */
+    NULL,                                   /* pStartDoc */
+    NULL,                                   /* pStartPage */
+    NULL,                                   /* pStretchBlt */
+    NULL,                                   /* pStretchDIBits */
+    NULL,                                   /* pStrokeAndFillPath */
+    NULL,                                   /* pStrokePath */
+    NULL,                                   /* pUnrealizePalette */
+    NULL,                                   /* pWidenPath */
+    boxeddrv_wine_get_wgl_driver,           /* wine_get_wgl_driver */
+    GDI_PRIORITY_GRAPHICS_DRV               /* priority */
+};
+
+/**********************************************************************
+*              CreateDC (BOXEDDRV.@)
+*/
+static BOOL boxeddrv_CreateDC(PHYSDEV *pdev, LPCWSTR driver, LPCWSTR device,
+	LPCWSTR output, const DEVMODEW* initData)
+{
+	BOXEDDRV_PDEVICE *physDev = create_boxed_physdev();
+
+	TRACE("pdev %p hdc %p driver %s device %s output %s initData %p\n", pdev,
+		(*pdev)->hdc, debugstr_w(driver), debugstr_w(device), debugstr_w(output),
+		initData);
+
+	if (!physDev) return FALSE;
+
+	push_dc_driver(pdev, &physDev->dev, &boxeddrv_funcs);
+	return TRUE;
+}
+
+
+/**********************************************************************
+*              CreateCompatibleDC (BOXEDDRV.@)
+*/
+static BOOL boxeddrv_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev)
+{
+	BOXEDDRV_PDEVICE *physDev = create_boxed_physdev();
+
+	TRACE("orig %p orig->hdc %p pdev %p pdev->hdc %p\n", orig, (orig ? orig->hdc : NULL), pdev,
+		((pdev && *pdev) ? (*pdev)->hdc : NULL));
+
+	if (!physDev) return FALSE;
+
+	push_dc_driver(pdev, &physDev->dev, &boxeddrv_funcs);
+	return TRUE;
+}
+
+/******************************************************************************
+ *              boxeddrv_get_gdi_driver
+ */
+const struct gdi_dc_funcs * CDECL boxeddrv_get_gdi_driver(unsigned int version)
+{
+    if (version != WINE_GDI_DRIVER_VERSION)
+    {
+        ERR("version mismatch, gdi32 wants %u but wineboxed has %u\n", version, WINE_GDI_DRIVER_VERSION);
+        return NULL;
+    }
+    return &boxeddrv_funcs;
+}
+
diff --git a/dlls/wineboxed.drv/wineboxed.drv.spec b/dlls/wineboxed.drv/wineboxed.drv.spec
new file mode 100755
index 0000000..5c770a0
--- /dev/null
+++ b/dlls/wineboxed.drv/wineboxed.drv.spec
@@ -0,0 +1,72 @@
+# GDI driver
+
+@ cdecl wine_get_gdi_driver(long) boxeddrv_get_gdi_driver
+
+# USER driver
+
+@ cdecl ActivateKeyboardLayout(long long) boxeddrv_ActivateKeyboardLayout
+@ cdecl Beep() boxeddrv_Beep
+@ cdecl ChangeDisplaySettingsEx(ptr ptr long long long) boxeddrv_ChangeDisplaySettingsEx
+@ cdecl ClipCursor(ptr) boxeddrv_ClipCursor
+@ cdecl CountClipboardFormats() boxeddrv_CountClipboardFormats
+@ cdecl CreateDesktopWindow(long) boxeddrv_CreateDesktopWindow
+@ cdecl CreateWindow(long) boxeddrv_CreateWindow
+@ cdecl DestroyCursorIcon(long) boxeddrv_DestroyCursorIcon
+@ cdecl DestroyWindow(long) boxeddrv_DestroyWindow
+@ cdecl EmptyClipboard() boxeddrv_EmptyClipboard
+@ cdecl EndClipboardUpdate() boxeddrv_EndClipboardUpdate
+@ cdecl EnumClipboardFormats(long) boxeddrv_EnumClipboardFormats
+@ cdecl EnumDisplayMonitors(long ptr ptr long) boxeddrv_EnumDisplayMonitors
+@ cdecl EnumDisplaySettingsEx(ptr long ptr long) boxeddrv_EnumDisplaySettingsEx
+@ cdecl GetClipboardData(long) boxeddrv_GetClipboardData
+@ cdecl GetCursorPos(ptr) boxeddrv_GetCursorPos
+@ cdecl GetKeyboardLayout(long) boxeddrv_GetKeyboardLayout
+@ cdecl GetKeyboardLayoutList(long ptr) boxeddrv_GetKeyboardLayoutList
+@ cdecl GetKeyboardLayoutName(ptr) boxeddrv_GetKeyboardLayoutName
+@ cdecl GetKeyNameText(long ptr long) boxeddrv_GetKeyNameText
+@ cdecl GetMonitorInfo(long ptr) boxeddrv_GetMonitorInfo
+@ cdecl IsClipboardFormatAvailable(long) boxeddrv_IsClipboardFormatAvailable
+@ cdecl MapVirtualKeyEx(long long long) boxeddrv_MapVirtualKeyEx
+@ cdecl MsgWaitForMultipleObjectsEx(long ptr long long long) boxeddrv_MsgWaitForMultipleObjectsEx
+@ cdecl RegisterHotKey(long long long) boxeddrv_RegisterHotKey
+@ cdecl SetCapture(long long) boxeddrv_SetCapture
+@ cdecl SetClipboardData(long long long) boxeddrv_SetClipboardData
+@ cdecl SetCursor(long) boxeddrv_SetCursor
+@ cdecl SetCursorPos(long long) boxeddrv_SetCursorPos
+@ cdecl SetFocus(long) boxeddrv_SetFocus
+@ cdecl SetLayeredWindowAttributes(long long long long) boxeddrv_SetLayeredWindowAttributes
+@ cdecl SetParent(long long long) boxeddrv_SetParent
+@ cdecl SetWindowRgn(long long long) boxeddrv_SetWindowRgn
+@ cdecl SetWindowStyle(ptr long ptr) boxeddrv_SetWindowStyle
+@ cdecl SetWindowText(long wstr) boxeddrv_SetWindowText
+@ cdecl ShowWindow(long long ptr long) boxeddrv_ShowWindow
+@ cdecl SysCommand(long long long) boxeddrv_SysCommand
+@ cdecl SystemParametersInfo(long long ptr long) boxeddrv_SystemParametersInfo
+@ cdecl ToUnicodeEx(long long ptr ptr long long long) boxeddrv_ToUnicodeEx
+@ cdecl UnregisterHotKey(long long long) boxeddrv_UnregisterHotKey
+@ cdecl UpdateLayeredWindow(long ptr ptr) boxeddrv_UpdateLayeredWindow
+@ cdecl VkKeyScanEx(long long) boxeddrv_VkKeyScanEx
+@ cdecl WindowMessage(long long long long) boxeddrv_WindowMessage
+@ cdecl WindowPosChanged(long long long ptr ptr ptr ptr ptr) boxeddrv_WindowPosChanged
+@ cdecl WindowPosChanging(long long long ptr ptr ptr ptr) boxeddrv_WindowPosChanging
+
+# System tray
+@ cdecl wine_notify_icon(long ptr)
+
+# IME
+@ stdcall ImeConfigure(long long long ptr)
+@ stdcall ImeConversionList(long wstr ptr long long)
+@ stdcall ImeDestroy(long)
+@ stdcall ImeEnumRegisterWord(ptr wstr long wstr ptr)
+@ stdcall ImeEscape(long long ptr)
+@ stdcall ImeGetImeMenuItems(long long long ptr ptr long)
+@ stdcall ImeGetRegisterWordStyle(long ptr)
+@ stdcall ImeInquire(ptr wstr wstr)
+@ stdcall ImeProcessKey(long long long ptr)
+@ stdcall ImeRegisterWord(wstr long wstr)
+@ stdcall ImeSelect(long long)
+@ stdcall ImeSetActiveContext(long long)
+@ stdcall ImeSetCompositionString(long long ptr long ptr long)
+@ stdcall ImeToAsciiEx(long long ptr ptr long long)
+@ stdcall ImeUnregisterWord(wstr long wstr)
+@ stdcall NotifyIME(long long long long)
diff --git a/dlls/wineboxed.drv/wineboxed.rc b/dlls/wineboxed.drv/wineboxed.rc
new file mode 100755
index 0000000..d5b7496
--- /dev/null
+++ b/dlls/wineboxed.drv/wineboxed.rc
@@ -0,0 +1,49 @@
+/*
+ * Resource file for BoxedWine driver
+ *
+ * Copyright (c) 2007 Alexandre Julliard
+ * Copyright (c) 2013 Ken Thomases for CodeWeavers Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <winnt.h>
+#include "boxeddrv_res.h"
+
+#pragma makedep po
+
+LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT
+
+STRINGTABLE
+{
+    STRING_MENU_WINE                        "Wine"
+    STRING_MENU_ITEM_HIDE_APPNAME           "Hide %@"
+    STRING_MENU_ITEM_HIDE                   "Hide"
+    STRING_MENU_ITEM_HIDE_OTHERS            "Hide Others"
+    STRING_MENU_ITEM_SHOW_ALL               "Show All"
+    STRING_MENU_ITEM_QUIT_APPNAME           "Quit %@"
+    STRING_MENU_ITEM_QUIT                   "Quit"
+
+    STRING_MENU_WINDOW                      "Window"
+    STRING_MENU_ITEM_MINIMIZE               "Minimize"
+    STRING_MENU_ITEM_ZOOM                   "Zoom"
+    STRING_MENU_ITEM_ENTER_FULL_SCREEN      "Enter Full Screen"
+    STRING_MENU_ITEM_BRING_ALL_TO_FRONT     "Bring All to Front"
+}
+
+#define WINE_FILEDESCRIPTION_STR "Wine BoxedWine driver"
+#define WINE_FILENAME_STR "wineboxed.drv"
+
+#include "wine/wine_common_ver.rc"
diff --git a/libs/wine/config.c b/libs/wine/config.c
index 3b5dd68..a01acd9 100644
--- a/libs/wine/config.c
+++ b/libs/wine/config.c
@@ -487,7 +487,7 @@ const char *wine_get_build_id(void)
 /* exec a binary using the preloader if requested; helper for wine_exec_wine_binary */
 static void preloader_exec( char **argv, int use_preloader )
 {
-    if (use_preloader)
+    if (0)
     {
         static const char preloader[] = "wine-preloader";
         static const char preloader64[] = "wine64-preloader";
diff --git a/libs/wine/loader.c b/libs/wine/loader.c
index b5b32cc..1be7626 100644
--- a/libs/wine/loader.c
+++ b/libs/wine/loader.c
@@ -935,7 +935,7 @@ void wine_init( int argc, char *argv[], char *error, int error_size )
     __wine_main_argc = argc;
     __wine_main_argv = argv;
     __wine_main_environ = __wine_get_main_environment();
-    mmap_init();
+    //mmap_init();
 
     for (path = first_dll_path( "ntdll.dll", 0, &context ); path; path = next_dll_path( &context ))
     {
diff --git a/server/Makefile.in b/server/Makefile.in
index 75ba199..31732a8 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -1,4 +1,5 @@
 PROGRAMS = wineserver
+LDFLAGS = -pie
 
 C_SRCS = \
 	async.c \
diff --git a/server/request.c b/server/request.c
index 597bf88..a488999 100644
--- a/server/request.c
+++ b/server/request.c
@@ -824,7 +824,8 @@ void open_master_socket(void)
 
     create_server_dir( server_dir );
 
-    if (!foreground)
+    // boxedwine without MMU cannot fork like this, and its not necessary for boxedwine
+    if (0)
     {
         if (pipe( sync_pipe ) == -1) fatal_error( "pipe: %s\n", strerror( errno ));
         pid = fork();
